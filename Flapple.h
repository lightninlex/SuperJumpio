#if defined(__AVR__)
    #include <avr/pgmspace.h>
#elif defined(__PIC32MX__)
    #define PROGMEM
#elif defined(__arm__)
    #define PROGMEM
#endif

const unsigned short Flapple[256] PROGMEM ={
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0010 (16)
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0020 (32)
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0030 (48)
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xF7DE,   // 0x0040 (64)
  0xFFFF, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x07E0, 0x07E0, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000, 0xFFFF,   // 0x0050 (80)
  0x0000, 0xFFDE, 0x0000, 0xFFFF, 0x0000, 0x0000, 0xFFFF, 0x07E0, 0x07E0, 0xFFFF, 0x0000, 0x0000, 0xFFFF, 0x0000, 0xFFDE, 0x0000,   // 0x0060 (96)
  0x0000, 0xFFDE, 0xFFDE, 0x0000, 0xF800, 0xF800, 0x0000, 0x0000, 0x0000, 0x0000, 0xF800, 0xF800, 0x0000, 0xFFDE, 0xFFDE, 0x0000,   // 0x0070 (112)
  0xFFFF, 0x0000, 0xFFDE, 0x0000, 0xF800, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xF800, 0x0000, 0xFFDE, 0x0000, 0xFFFF,   // 0x0080 (128)
  0x0000, 0xFFDE, 0xFFDE, 0x0000, 0xF800, 0xF800, 0x0000, 0xF800, 0xF800, 0x0000, 0xF800, 0xF800, 0x0000, 0xFFDE, 0xFFDE, 0x0000,   // 0x0090 (144)
  0x0000, 0xFFDE, 0xFFDE, 0xFFDE, 0x0000, 0xF800, 0xF800, 0xFFE0, 0xFFE0, 0xF800, 0xF800, 0x0000, 0xFFDE, 0xFFDE, 0xFFDE, 0x0000,   // 0x00A0 (160)
  0xFFFF, 0x0000, 0x0000, 0xFFDE, 0xFFDE, 0x0000, 0xFFE0, 0xFFE0, 0xFFE0, 0xF800, 0x0000, 0xFFDE, 0xFFDE, 0x0000, 0x0000, 0xFFFF,   // 0x00B0 (176)
  0xFFFF, 0xFFFF, 0x0000, 0xFFDE, 0x0000, 0xFFFF, 0x0000, 0xF800, 0xF800, 0x0000, 0xFFFF, 0x0000, 0xFFDE, 0x0000, 0xFFFF, 0xFFFF,   // 0x00C0 (192)
  0xFFFF, 0xFFFF, 0x0000, 0x0000, 0xFFFF, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000, 0xFFFF, 0xFFFF, 0x0000, 0x0000, 0xFFFF, 0xFFFF,   // 0x00D0 (208)
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x00E0 (224)
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x00F0 (240)
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0100 (256)
};
const unsigned short FlappleFlap[256] PROGMEM ={
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0010 (16)
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0020 (32)
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0030 (48)
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xF7DE,   // 0x0040 (64)
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x07E0, 0x07E0, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0050 (80)
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000, 0x0000, 0xFFFF, 0x07E0, 0x07E0, 0xF79D, 0x0000, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0060 (96)
  0xFFFF, 0xFFFF, 0xFFFF, 0x0000, 0xF800, 0xF800, 0x0000, 0x0000, 0x0000, 0x0000, 0xF800, 0xF800, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0070 (112)
  0x0000, 0x0000, 0x0000, 0x0000, 0xF800, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xF800, 0x0000, 0x0000, 0x0000, 0x0000,   // 0x0080 (128)
  0x0000, 0xF79D, 0xF79D, 0x0000, 0xF800, 0xF800, 0x0000, 0xF800, 0xF800, 0x0000, 0xF800, 0xF800, 0x0000, 0xF79D, 0xF79D, 0x0000,   // 0x0090 (144)
  0xFFFF, 0x0000, 0xF79D, 0x0000, 0x0000, 0xF800, 0xF800, 0xFFE0, 0xFFE0, 0xF800, 0xF800, 0x0000, 0x0000, 0xF79D, 0x0000, 0xFFFF,   // 0x00A0 (160)
  0x0000, 0xF79D, 0xF79D, 0xF79D, 0xF79D, 0x0000, 0xFFE0, 0xFFE0, 0xFFE0, 0xF800, 0x0000, 0xF79D, 0xF79D, 0xF79D, 0xF79D, 0x0000,   // 0x00B0 (176)
  0x0000, 0xF79D, 0xF79D, 0xF79D, 0x0000, 0xFFFF, 0x0000, 0xF800, 0xF800, 0x0000, 0xFFFF, 0x0000, 0xF79D, 0xF79D, 0xF79D, 0x0000,   // 0x00C0 (192)
  0xFFFF, 0x0000, 0x0000, 0xF79D, 0x0000, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000, 0xFFFF, 0x0000, 0xF79D, 0x0000, 0x0000, 0xFFFF,   // 0x00D0 (208)
  0xFFFF, 0xFFFF, 0x0000, 0xF79D, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000, 0xF79D, 0x0000, 0xFFFF, 0xFFFF,   // 0x00E0 (224)
  0xFFFF, 0xFFFF, 0x0000, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000, 0x0000, 0xFFFF, 0xFFFF,   // 0x00F0 (240)
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0100 (256)
};
const unsigned short FlappleSquish[256] PROGMEM ={
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0010 (16)
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0020 (32)
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0030 (48)
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xF7DE,   // 0x0040 (64)
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0050 (80)
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0060 (96)
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0070 (112)
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xF7DE,   // 0x0080 (128)
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0090 (144)
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x00A0 (160)
  0xFFFF, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x07E0, 0x07E0, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000, 0xFFFF,   // 0x00B0 (176)
  0x0000, 0xFFDE, 0xFFDE, 0x0000, 0xF800, 0xF800, 0x0000, 0x0000, 0x0000, 0x0000, 0xF800, 0xF800, 0x0000, 0xFFDE, 0xFFDE, 0x0000,   // 0x00C0 (192)
  0x0000, 0xFFDE, 0xFFDE, 0x0000, 0xF800, 0xF800, 0x0000, 0xF800, 0xF800, 0x0000, 0xF800, 0xF800, 0x0000, 0xFFDE, 0xFFDE, 0x0000,   // 0x00D0 (208)
  0xFFFF, 0x0000, 0x0000, 0xFFDE, 0xFFDE, 0x0000, 0xFFE0, 0xFFE0, 0xFFE0, 0xF800, 0x0000, 0xFFDE, 0xFFDE, 0x0000, 0x0000, 0xFFFF,   // 0x00E0 (224)
  0xFFFF, 0xFFFF, 0x0000, 0x0000, 0xFFFF, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000, 0xFFFF, 0xFFFF, 0x0000, 0x0000, 0xFFFF, 0xFFFF,   // 0x00F0 (240)
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0100 (256)
};
#include <TFT_eSPI.h>
struct FlappleObj {
    TFT_eSprite flapplesprite;
    int xPos;
    int yPos;
    unsigned long prevMillis;
    int movementCounter;
    int movementSpeed;
    const int updateInterval = 99;
    bool isSquished;
    unsigned long squishStartTime;
    const unsigned long squishDuration = 66;
    bool usingFlappleSprite;
    bool movingUp;
    float flappleSpeedMultiplier = 1.0;
    int minSpeed = 2;
    int maxSpeed = 8;
  FlappleObj(TFT_eSPI *tft) : flapplesprite(tft), xPos(random((16*5), (16*50))), yPos(170), movingUp(true), movementSpeed(3), movementCounter(0) {
        flapplesprite.createSprite(16, 16);
        flapplesprite.setSwapBytes(true);
        flapplesprite.fillSprite(TFT_WHITE);
}
void update(int cameraPosX) {
 
            // Vertical movement logic
        if (movingUp) {
            yPos -= static_cast<int>(movementSpeed * flappleSpeedMultiplier);
        } else {
            yPos += static_cast<int>(movementSpeed * flappleSpeedMultiplier);
        }
      // Invert movement direction if it reaches the top or bottom of its movement range
        if ((yPos <= 48 && movingUp) || (yPos >= 160 && !movingUp)) {
            movingUp = !movingUp;
            movementSpeed = random(minSpeed, maxSpeed);
        }
      // Switch between Flapple and FlappleFlap sprites
        if (usingFlappleSprite) {
            flapplesprite.pushImage(0, 0, 16, 16, Flapple);
          } else {
            flapplesprite.pushImage(0, 0, 16, 16, FlappleFlap);
            }
      // Reset Flapple if squished
        if (isSquished && millis() - squishStartTime >= squishDuration) {
            isSquished = false;
            movingUp = false;
            xPos = random((16*5), (16*162)); // Reset position
            yPos = 160;
        }
      // Calculate on-screen position and draw the sprite
        int screenX = xPos - cameraPosX;
        if (screenX >= 0 && screenX < SCREEN_WIDTH) {
            flapplesprite.pushSprite(screenX, yPos, TFT_WHITE);
        }
      // Update sprite animation
        movementCounter++;
        if (movementCounter >= 9) {
            movementCounter = 0;
            usingFlappleSprite = !usingFlappleSprite;
        }
}
void checkCollision(int cameraPosX, const JumpioCharacter& jumpio) {
  const int spriteSize = 16;
  int screenX = xPos - cameraPosX;
  int jumpioScreenX = jumpio.xPos - cameraPosX;
  int jumpioScreenY = jumpio.yPos;
  bool overlapX = (jumpioScreenX < screenX + spriteSize) && (jumpioScreenX + spriteSize > screenX);
  bool overlapY = (jumpioScreenY < yPos + spriteSize) && (jumpioScreenY + spriteSize > yPos);
      if (overlapX && overlapY) {
        flappleSquish();
      }
}
void flappleSquish() {
    if (!isSquished) {
      isSquished = true;
      movingUp = true;
      movementSpeed += 0.5;
        if (movementSpeed >= 8) {
        movementSpeed = random(minSpeed, maxSpeed);
        }
        squishStartTime = millis();
        flapplesprite.pushImage(0, 0, 16, 16, FlappleSquish);
    }
}
};
