#if defined(__AVR__)
    #include <avr/pgmspace.h>
#elif defined(__PIC32MX__)
    #define PROGMEM
#elif defined(__arm__)
    #define PROGMEM
#endif

const unsigned short Gloomble[256] PROGMEM={
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0010 (16) pixels
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0020 (32) pixels
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000, 0xEF5C, 0xEF5C, 0xF800, 0xF800, 0xF800, 0xF800, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0030 (48) pixels
  0xFFFF, 0xFFFF, 0xFFFF, 0x0000, 0xF800, 0xEF5C, 0xEF5C, 0xF800, 0xF800, 0xEF5C, 0xEF5C, 0xF800, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0040 (64) pixels
  0xFFFF, 0xFFFF, 0x0000, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xEF5C, 0xEF5C, 0xF800, 0xF800, 0x0000, 0xFFFF, 0xFFFF,   // 0x0050 (80) pixels
  0xFFFF, 0x0000, 0xF800, 0x0000, 0x0000, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0x0000, 0x0000, 0xF800, 0x0000, 0xFFFF,   // 0x0060 (96) pixels
  0xFFFF, 0x0000, 0xF800, 0xF800, 0xEF5C, 0x0000, 0xF800, 0xF800, 0xF800, 0xF800, 0x0000, 0xEF5C, 0xF800, 0xF800, 0xF800, 0x0000,   // 0x0070 (112) pixels
  0x0000, 0xF800, 0xF800, 0xF800, 0xEF5C, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xEF5C, 0xF800, 0xF800, 0xF800, 0x0000,   // 0x0080 (128) pixels
  0x0000, 0xF800, 0xF800, 0xF800, 0xEF5C, 0x0000, 0xEF5C, 0xF800, 0xF800, 0xEF5C, 0x0000, 0xEF5C, 0xF800, 0xF800, 0xEF5C, 0x0000,   // 0x0090 (144) pixels
  0x0000, 0xEF5C, 0xEF5C, 0xF800, 0xEF5C, 0xEF5C, 0xEF5C, 0xF800, 0xF800, 0xEF5C, 0xEF5C, 0xEF5C, 0xF800, 0xF800, 0xF800, 0x0000,   // 0x00A0 (160) pixels
  0x0000, 0xF800, 0xEF5C, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xFFFF,   // 0x00B0 (176) pixels
  0xFFFF, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xF73A, 0xF73A, 0xF73A, 0xF73A, 0xF800, 0xEF5C, 0xEF5C, 0xF800, 0x0000, 0xFFFF,   // 0x00C0 (192) pixels
  0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000, 0xF73A, 0xF73A, 0xF73A, 0xF73A, 0xF73A, 0xF73A, 0x0000, 0x0000, 0x0000, 0x0000, 0xFFFF,   // 0x00D0 (208) pixels
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000, 0xF73A, 0xF73A, 0xF73A, 0xF73A, 0xF73A, 0xF73A, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x00E0 (224) pixels
  0xFFFF, 0xFFFF, 0xFFFF, 0x0000, 0x7A64, 0x7A64, 0xF73A, 0xF73A, 0xF73A, 0xF73A, 0x7A64, 0x7A64, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x00F0 (240) pixels
  0xFFFF, 0xFFFF, 0x0000, 0x7A64, 0x7A64, 0x7A64, 0x7A64, 0x0000, 0x0000, 0x7A64, 0x7A64, 0x7A64, 0x7A64, 0x0000, 0xFFFF, 0xFFFF,   // 0x0100 (256) pixels
};
const unsigned short GloombleWalk[256] PROGMEM={
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0010 (16) pixels
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0020 (32) pixels
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000, 0xEF5C, 0xEF5C, 0xF800, 0xF800, 0xF800, 0xF800, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0030 (48) pixels
  0xFFFF, 0xFFFF, 0xFFFF, 0x0000, 0xF800, 0xEF5C, 0xEF5C, 0xF800, 0xF800, 0xEF5C, 0xEF5C, 0xF800, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0040 (64) pixels
  0xFFFF, 0xFFFF, 0x0000, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xEF5C, 0xEF5C, 0xF800, 0xF800, 0x0000, 0xFFFF, 0xFFFF,   // 0x0050 (80) pixels
  0xFFFF, 0x0000, 0xF800, 0x0000, 0x0000, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0x0000, 0x0000, 0xF800, 0x0000, 0xFFFF,   // 0x0060 (96) pixels
  0xFFFF, 0x0000, 0xF800, 0xF800, 0xF73A, 0x0000, 0xF800, 0xF800, 0xF800, 0xF800, 0x0000, 0xF73A, 0xF800, 0xF800, 0xF800, 0x0000,   // 0x0070 (112) pixels
  0x0000, 0xF800, 0xF800, 0xF800, 0xF73A, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xF73A, 0xF800, 0xF800, 0xF800, 0x0000,   // 0x0080 (128) pixels
  0x0000, 0xF800, 0xF800, 0xF800, 0xF73A, 0x0000, 0xF73A, 0xF800, 0xF800, 0xF73A, 0x0000, 0xF73A, 0xF800, 0xF800, 0xEF5C, 0x0000,   // 0x0090 (144) pixels
  0x0000, 0xEF5C, 0xEF5C, 0xF800, 0xF73A, 0xF73A, 0xF73A, 0xF800, 0xF800, 0xF73A, 0xF73A, 0xF73A, 0xF800, 0xF800, 0xF800, 0x0000,   // 0x00A0 (160) pixels
  0x0000, 0xF800, 0xEF5C, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xFFFF,   // 0x00B0 (176) pixels
  0xFFFF, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xF73A, 0xF73A, 0xF73A, 0xF73A, 0xF800, 0xEF5C, 0xEF5C, 0xF800, 0x0000, 0xFFFF,   // 0x00C0 (192) pixels
  0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000, 0xF73A, 0xF73A, 0xF73A, 0xF73A, 0xF73A, 0xF73A, 0x0000, 0x0000, 0x0000, 0x0000, 0xFFFF,   // 0x00D0 (208) pixels
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000, 0xF73A, 0xF73A, 0xF73A, 0xF73A, 0xF73A, 0xF73A, 0x0000, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x00E0 (224) pixels
  0xFFFF, 0x0000, 0x7A64, 0x7A64, 0x7A64, 0x0000, 0xF73A, 0xF73A, 0xF73A, 0x7A64, 0x7A64, 0x7A64, 0x7A64, 0x0000, 0xFFFF, 0xFFFF,   // 0x00F0 (240) pixels
  0xFFFF, 0x0000, 0x7A64, 0x7A64, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000, 0x7A64, 0x7A64, 0x7A64, 0x7A64, 0x7A64, 0x0000, 0xFFFF,   // 0x0100 (256) pixels
};
const unsigned short GloombleSquish[256] PROGMEM={
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0010 (16) pixels
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0020 (32) pixels
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0030 (48) pixels
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0040 (64) pixels
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0050 (80) pixels
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0060 (96) pixels
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0070 (112) pixels
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0080 (128) pixels
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0090 (144) pixels
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x00A0 (160) pixels
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x00B0 (176) pixels
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x00C0 (192) pixels
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x00D0 (208) pixels
  0xFFFF, 0xFFFF, 0xFFFF, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x00E0 (224) pixels
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xF73A, 0xF73A, 0xF73A, 0xF73A, 0xF73A, 0xF73A, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x00F0 (240) pixels
  0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x7A64, 0x7A64, 0x7A64, 0x7A64, 0x0000, 0x7A64, 0x7A64, 0x7A64, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,   // 0x0100 (256) pixels
};
#include <TFT_eSPI.h>
struct GloombleObj {
  TFT_eSprite gloomblesprite;  // Sprite for Jumpio
  int xPos;
  int yPos = 192;
  int prevYPos = yPos;
  unsigned long prevMillis;
  int movementCounter;
  const int updateInterval = 66;
  bool isSquished;
  unsigned long squishStartTime;
  const unsigned long squishDuration = 66; // Duration in milliseconds
  bool usingGloombleSprite; // To track which sprite is currently in use
  bool movingLeft = true; // New variable to track movement direction
  bool spawnedOnRight;
  float movementSpeed;
  unsigned long lastEdgeHitTime;
  unsigned long spawnDelay;
  float minSpeed = 4;
  float maxSpeed = 6;
  float gloombleSpeedMultiplier = 1.0;
  int worldXPos = xPos + cameraPosX;
  int tileX = worldXPos / TILE_WIDTH;
  int jumpioX = jumpio.xPos;
  int jumpioY = jumpio.yPos;
    GloombleObj(TFT_eSPI *tft, unsigned long _spawnDelay) : gloomblesprite(tft), xPos(320), yPos(192), movingLeft(true), movementSpeed(3), spawnedOnRight(false), lastEdgeHitTime(0), spawnDelay(_spawnDelay) {
      gloomblesprite.createSprite(16, 16);
      gloomblesprite.setSwapBytes(true);
      gloomblesprite.fillSprite(TFT_WHITE); // Assuming TFT_WHITE is the background color
} 
void spawnOnRightAfterDelay() {
      if (!spawnedOnRight && millis() - lastEdgeHitTime > spawnDelay) {
          xPos = jumpio.xPos+300; // Spawn on the right side
          yPos = 192;
          spawnedOnRight = true;
        }
}
  void redrawPath(int oldX, int oldY, int newX, int newY, int spriteWidth, int spriteHeight, int jumpioX, int jumpioY) {
    int startTileX = min(oldX, newX) / TILE_WIDTH;
    int endTileX = max(oldX + spriteWidth, newX + spriteWidth) / TILE_WIDTH;
    int startTileY = min(oldY, newY) / TILE_HEIGHT;
    int endTileY = max(oldY + spriteHeight, newY + spriteHeight) / TILE_HEIGHT;

      for (int x = startTileX; x <= endTileX; x++) {
        for (int y = startTileY; y <= endTileY; y++) {
              // Check if this tile overlaps with Jumpio's position
            if (x == jumpio.xPos / TILE_WIDTH && y == jumpio.yPos / TILE_HEIGHT) {
                continue; // Skip redrawing this tile
            }
            redrawTile(x * TILE_WIDTH, y * TILE_HEIGHT);
        }
    }
}
void update( int jumpioX, int jumpioY) {
  spawnOnRightAfterDelay();
   // Calculate the tile index beneath the Gloomble
    int tileX = xPos / TILE_WIDTH;
    int tileBelowY = (yPos + 16) / TILE_HEIGHT; // Assuming Gloomble's height is 16
    // Check for valid array indices
      if (tileX >= 0 && tileX < 162 && tileBelowY > 0 && tileBelowY < 15 && jumpio.isDashing) {
        // Check if the tile below is not a solid ground
        if (backgroundMap[tileBelowY][tileX] != 1) {
            // Reverse direction
            movingLeft = !movingLeft;
        }
      }
      if (tileX >= 0 && tileX < 162 && tileBelowY > 0 && tileBelowY < 15 && !jumpio.isDashing) {
        // Check if the tile below is not a solid ground
        if (backgroundMap[tileBelowY][tileX] != 1) {
            // Reverse direction
            movingLeft = !movingLeft;
        }
      }
     // Adjust Gloomble's movement based on Jumpio's dashing state
  if (jumpio.isDashing) {
    movingLeft = true;
    // Move Gloomble at the same rate as Jumpio's dash
    xPos -= jumpio.jumpioSpeedMultiplier * 3;
  } else {
    // Standard movement logic
    if (movingLeft) {
      xPos -= movementSpeed * gloombleSpeedMultiplier;
    } else {
      xPos += movementSpeed * gloombleSpeedMultiplier;
    }
  }
  if(yPos >= 240){
    spawnedOnRight = false;
  }
    // Handle screen edge collision
      if (xPos > 330 && !movingLeft) {
    // Change movement direction
        movingLeft = !movingLeft;
    // Increase movement speed
        movementSpeed = random(minSpeed, maxSpeed);
    // Update last edge hit time
        lastEdgeHitTime = millis();
    }
    if (xPos < 0 && movingLeft){
    spawnedOnRight = false;
    }
    if (xPos < 10 && jumpio.isDashing){
      spawnedOnRight = false;
    }
    // Load the correct sprite based on the state
      if (usingGloombleSprite) {
      gloomblesprite.pushImage(0, 0, 16, 16, Gloomble);
     } else {
      gloomblesprite.pushImage(0, 0, 16, 16, GloombleWalk);
    }
    // Check if the Gloomble is squished and if the squish duration has elapsed
  if (isSquished && millis() - squishStartTime >= squishDuration) {
    isSquished = false;
    xPos = jumpio.xPos+300; // Reset position
    yPos = 192;
    // Optionally switch back to the normal sprite
    gloomblesprite.pushImage(0, 0, 16, 16, Gloomble); // Use the normal sprite
    gloomblesprite.pushSprite(xPos, yPos, TFT_WHITE);
  }
    // Draw the sprite at the new position
    gloomblesprite.pushSprite(xPos, yPos, TFT_WHITE);
    movementCounter++;
}
void checkTile() {
    int worldXPos = xPos + cameraPosX;

    // Calculate front tile position
    int adjustedFrontXPos = movingLeft ? (worldXPos - 16) : (worldXPos + 16);
    int frontTileX = adjustedFrontXPos / TILE_WIDTH;
    int frontTileY = (yPos - 8) / TILE_HEIGHT; // Checking the tile at Gloomble's mid-height

    // Calculate the tile diagonally down and in front
    int diagonalTileX = adjustedFrontXPos / TILE_WIDTH;
    int diagonalTileY = (yPos + 16) / TILE_HEIGHT; // Diagonally down and in front of Gloomble

    bool frontSolid = false;
    bool diagonalNonSolid = false;

    // Check if front tile is solid
    if (frontTileX >= 0 && frontTileX < 162 && frontTileY >= 0 && frontTileY < 15) {
        frontSolid = (backgroundMap[frontTileY][frontTileX] == 1);
    }

    // Check if the tile diagonally down and in front is non-solid
    if (diagonalTileX >= 0 && diagonalTileX < 162 && diagonalTileY >= 0 && diagonalTileY < 15) {
        diagonalNonSolid = (backgroundMap[diagonalTileY][diagonalTileX] != 1);
    }

    // Change direction if front tile is solid or if the diagonal tile is non-solid
    if (frontSolid || diagonalNonSolid) {
      if (jumpio.isDashing){
        spawnedOnRight = false;
      }
        movingLeft = !movingLeft;
    }
}
void checkCollision() {
    const int spriteSize = 16;
    const int topCollisionThreshold = (spriteSize / 4)*3; // Fine-tune this value
    // Check horizontal overlap
    if (jumpio.xPos - cameraPosX < xPos + spriteSize && (jumpio.xPos - cameraPosX) + spriteSize > xPos) {
        // Check vertical overlap
        if (jumpio.yPos + spriteSize > yPos && jumpio.yPos < yPos + spriteSize) {
            // Top collision
            if (jumpio.isDashing){
              jumpio.bounce(-13.0);
              gloombleSquish();
            }
            else if (jumpio.yPos + spriteSize - gravity * 4 <= yPos + topCollisionThreshold) {
                jumpio.bounce(-12); // Adjust the value as needed for the bounce
                gloombleSquish();
            } else {
                spawnedOnRight = false;
                // Side or bottom collision
                jumpio.reset();
                jumpio.resetJumpio();
            }
        }
    }
}
void gloombleSquish() {
  if (!isSquished) {
    spawnedOnRight = false;
    isSquished = true;
    movingLeft = true;
    movementSpeed += 0.5;
    if (movementSpeed >= 8) {
      movementSpeed = random(minSpeed, maxSpeed);
    }
    squishStartTime = millis();
    gloomblesprite.pushImage(0, 0, 16, 16, GloombleSquish);
    gloomblesprite.pushSprite(xPos, yPos, TFT_WHITE);
  }
}
};